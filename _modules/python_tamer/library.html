
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python_tamer.library &#8212; python-TAMER 0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for python_tamer.library</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; python_TAMER &quot;&quot;&quot;</span> 

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This library contains two classes at present: SpecificDoses and ExposureMap. Each class has</span>
<span class="sd">a typical pipeline of operations the user can work through to produce the desired results:</span>
<span class="sd">specific ambient and personal dose estimations or maps of some exposure metric respectively.</span>
<span class="sd">Currently, the dataset only works with the Vuilleumier et al. erythemal UV dataset for</span>
<span class="sd">Switzerland. See https://doi.org/10.1016/j.envint.2020.106177 for more information.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">netCDF4</span> <span class="k">as</span> <span class="nn">nc</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">cartopy.crs</span> <span class="k">as</span> <span class="nn">ccrs</span>
<span class="kn">import</span> <span class="nn">cartopy.feature</span> <span class="k">as</span> <span class="nn">cfeat</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">regex</span> <span class="k">as</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">.subroutines</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.initial_reference</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="SpecificDoses"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.SpecificDoses">[docs]</a><span class="k">class</span> <span class="nc">SpecificDoses</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;SpecificDoses is the class for replicating dosimetry measurements</span>

<span class="sd">    High resolution data allows for personal and ambient dose estimation without the need for</span>
<span class="sd">    direct measurement. This class is structured like a table with a set of functions to add </span>
<span class="sd">    columns ultimately leading to dose estimates. Each row of this table represents a specific</span>
<span class="sd">    exposure instance, i.e. an individual at a specific location for a specific date and time</span>
<span class="sd">    with a specific exposure ratio. See Harris et al. 2021 </span>
<span class="sd">    (https://doi.org/10.3390/atmos12020268) for more information on calculations appropriate </span>
<span class="sd">    for this class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nc_filename_format : str</span>
<span class="sd">        Describes the filename of the netCDF files containing the UV data with &#39;yyyy&#39; in place </span>
<span class="sd">        of the year.</span>
<span class="sd">    </span>
<span class="sd">    data_directory : str</span>
<span class="sd">        The directory where the data is stored. Must end with a slash.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This property ensures that functions return the same subclass</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SpecificDoses</span>
    
    <span class="c1"># This adds some useful metadata (self-explanatory)</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;nc_filename_format&quot;</span><span class="p">,</span><span class="s2">&quot;data_directory&quot;</span><span class="p">]</span>
    <span class="n">nc_filename_format</span> <span class="o">=</span> <span class="n">default_nc_filename_format</span>
    <span class="n">data_directory</span> <span class="o">=</span> <span class="n">default_data_directory</span> <span class="c1"># TO DO: set up __init__ for these options</span>
    <span class="c1"># It feels like this should be declared with __init__ as well but idk</span>

<div class="viewcode-block" id="SpecificDoses.schedule_constant_exposure"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.SpecificDoses.schedule_constant_exposure">[docs]</a>    <span class="k">def</span> <span class="nf">schedule_constant_exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;schedule_constant_exposure generates exposure schedules given start and end times.</span>

<span class="sd">        This function generates exposure schedules based on simple continuous exposure, i.e.</span>
<span class="sd">        with a start time and an end time. The exposure schedule is a vector with length 24</span>
<span class="sd">        with each entry representing the proportion of the corresponding hour of the day that</span>
<span class="sd">        the subject is exposed. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">schedule_constant_exposure_iter</span><span class="p">(</span><span class="n">Start_time</span><span class="p">,</span><span class="n">End_time</span><span class="p">)</span> <span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Iterates through rows of a SpecificDoses table to generate schedules.</span>

<span class="sd">            This function is designed to be applied to each row in a datatable to generate an</span>
<span class="sd">            exposure schedule based on a start time and end time</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            Start_time : datetime.time</span>
<span class="sd">                UTC time at which exposure period begins</span>
<span class="sd">            End_time : datetime.time</span>
<span class="sd">                UTC time at which exposure period end</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.array</span>
<span class="sd">                24 length vector of values between 0 and 1 indicating proportion </span>
<span class="sd">                    of time exposed for that corresponding hour of the day.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">schedule</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
            <span class="n">schedule</span><span class="p">[</span><span class="n">Start_time</span><span class="o">.</span><span class="n">hour</span><span class="p">:</span><span class="n">End_time</span><span class="o">.</span><span class="n">hour</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Modify start and end hours according to proportion of time exposed</span>
            <span class="k">if</span> <span class="n">Start_time</span><span class="o">.</span><span class="n">minute</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">schedule</span><span class="p">[</span><span class="n">Start_time</span><span class="o">.</span><span class="n">hour</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Start_time</span><span class="o">.</span><span class="n">minute</span><span class="o">/</span><span class="mi">60</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">End_time</span><span class="o">.</span><span class="n">minute</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">schedule</span><span class="p">[</span><span class="n">End_time</span><span class="o">.</span><span class="n">hour</span><span class="p">]</span> <span class="o">=</span> <span class="n">End_time</span><span class="o">.</span><span class="n">minute</span><span class="o">/</span><span class="mi">60</span> 

            <span class="k">return</span> <span class="n">schedule</span>
        <span class="c1"># With that function defined, we need just one line to apply it to the whole table</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Schedule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">schedule_constant_exposure_iter</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[</span><span class="s2">&quot;Time_start&quot;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;Time_end&quot;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="SpecificDoses.ER_from_posture"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.SpecificDoses.ER_from_posture">[docs]</a>    <span class="k">def</span> <span class="nf">ER_from_posture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
    <span class="n">Vis_table_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Vis_table</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ER_from_posture calculates Exposure Ratios for a given anatomic zone, posture, and date.</span>

<span class="sd">        This function calculates ER as a percentage between 0 and 100 based on information from an input table.</span>
<span class="sd">        The input table must contain certain columns at a minimum. Those are: Date, Anatomic_zone, and Posture.</span>
<span class="sd">        This function contains hard-coded synonyms for certain anatomical zones, e.g. &#39;Forehead&quot; maps to &quot;Face&#39;.</span>
<span class="sd">        See Vernez et al., Journal of Exposure Science and Environmental Epidemiology (2015) 25, 113â€“118 </span>
<span class="sd">        (doi:10.1038/jes.2014.6) for further details on the model used for the calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Vis_table_path : str, optional</span>
<span class="sd">            The full path to an alternative table for the Vis parameter. </span>
<span class="sd">                Must be a csv file. Defaults to None.</span>
<span class="sd">        Vis_table : str, optional</span>
<span class="sd">            An alternative table for the Vis parameter. Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpecificDoses</span>
<span class="sd">            Returns input table appended with ER column</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The SpecificDoses table used must contain columns for Date, Anatomic_zone, and Posture.</span>
<span class="sd">        The Date column should contain DateTime entries. The Anatonic_zone column should contain one string per </span>
<span class="sd">        row describing the exposed body part. The Posture column should contain one string per row describing </span>
<span class="sd">        one of six accepted postures.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This chunk of code checks if the default Vis table should be used or if the user enters some alternative table.</span>
        <span class="k">if</span> <span class="n">Vis_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Vis_table_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">Vis_table</span> <span class="o">=</span> <span class="n">Vernez_2015_vis_table</span>
            <span class="c1"># The &#39;standing moving&#39; posture must be dealt with somehow...</span>
            <span class="c1"># Vis_table[&#39;Standing moving&#39;]= (Vis_table[&#39;Standing erect arms down&#39;] + Vis_table[&#39;Standing bowing&#39;]) / 2</span>
            <span class="n">Vis_table</span><span class="p">[</span><span class="s1">&#39;Standing moving&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">Vis_table</span><span class="p">[</span><span class="s1">&#39;Standing erect arms down&#39;</span><span class="p">]</span> 
        <span class="k">elif</span> <span class="n">Vis_table</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">Vis_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">Vis_table_path</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;Anatomic_zone&#39;</span> <span class="p">:</span> <span class="n">Anatomic_zone_synonyms</span><span class="p">})</span>

        <span class="c1"># With the correct anatomic zone names established, we can lookup the Vis values from the table</span>
        <span class="n">Vis</span> <span class="o">=</span> <span class="n">Vis_table</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Anatomic_zone&#39;</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Posture&#39;</span><span class="p">])</span>

        <span class="c1"># Next we must calculate the minimal Solar Zenith Angle for the given date</span>
        <span class="n">mSZA</span> <span class="o">=</span> <span class="n">min_solar_zenith_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Date</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Latitude</span><span class="p">)</span>

        <span class="c1"># With the Vis value and the SZA, we can calculate the ER according to the Vernez model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;ER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ER_Vernez_model_equation</span><span class="p">(</span><span class="n">Vis</span><span class="p">,</span><span class="n">mSZA</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SpecificDoses.calculate_specific_dose"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.SpecificDoses.calculate_specific_dose">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_specific_dose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculates doses according to exposure schedule, ER, date, and location.</span>

<span class="sd">        This function takes the SpecificDoseEstimationTable and calculates the specific </span>
<span class="sd">        ambient and personal doses according to the exposure schedule and ER. There are</span>
<span class="sd">        a few key steps to this function. First it reads the Date column to determine </span>
<span class="sd">        which years of data must be loaded. It then iterates through each year, loading</span>
<span class="sd">        only the necessary dates. It applies the exposure schedule and the ER to </span>
<span class="sd">        calculate the ambient and personal doses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpecificDoses</span>
<span class="sd">            The input table is appended with a Ambient_dose and Personal_dose column.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The input SpecificDoses object must include Date, Schedule, ER, Latitude,</span>
<span class="sd">        and Longitude columns.</span>
<span class="sd">        Read Harris et al. 2021 (https://doi.org/10.3390/atmos12020268) for more </span>
<span class="sd">        information on how this function can be used in the context of mimicking UV</span>
<span class="sd">        dosimetry measurements.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First step is find unique years to avoid loading unnecessary data</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Date</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
        <span class="n">unique_years</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">years</span><span class="p">))</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Personal_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">unique_years</span> <span class="p">:</span>
            <span class="c1"># Load netCDF file</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing year &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> 
            <span class="n">dataset</span><span class="o">=</span><span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_directory</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;yyyy&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)))</span> 
            <span class="n">dataset</span><span class="o">.</span><span class="n">set_auto_mask</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># This is important for nans to import correctly</span>

            <span class="c1"># Make temporary table for yearly subset</span>
            <span class="n">temp_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">years</span> <span class="o">==</span> <span class="n">year</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># find all unique days in year to be loaded</span>
            <span class="n">unique_days</span><span class="p">,</span><span class="n">unique_days_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">temp_table</span><span class="o">.</span><span class="n">Date</span><span class="p">)</span><span class="o">.</span><span class="n">dayofyear</span><span class="p">,</span>
                <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;unique_days_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_days_idx</span>

            <span class="c1">#pd.DatetimeIndex(nc.num2date(dataset.variables[&quot;time&quot;][:],dataset.variables[&quot;time&quot;].units,only_use_cftime_datetimes=False))</span>

            <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">24</span> <span class="p">:</span>
                <span class="c1"># needed if just a single day</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="c1"># Next we pull a subset from the netCDF file</span>
                <span class="c1"># declare false array with same length of time dimension from netCDF</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span> 
                <span class="c1"># reshape false array to have first dimension 24 (hours in day)</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">time_subset</span><span class="p">)</span> 
                <span class="c1"># set the appropriate days as true</span>
                <span class="n">time_subset</span><span class="p">[:,</span><span class="n">unique_days</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 
                <span class="c1"># flatten time_subset array back to one dimension</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="n">time_subset</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;UV_AS&#39;</span><span class="p">][</span><span class="n">time_subset</span><span class="p">,:,:]</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span> 
            <span class="c1"># *40 converts it to uv index</span>
            <span class="c1"># TO DO: improve comprehension of raw data units rather than assuming</span>

            <span class="c1"># convert lat lon into pixel coordinates</span>
            <span class="c1"># TO DO: consider is necessary to load entire maps for just a few required pixels</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][:]</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:]</span>
            <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;pixel_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">find_nearest</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>
            <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;pixel_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">find_nearest</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

            
            <span class="c1"># calculate doses</span>
            <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;unique_days_idx&#39;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;pixel_lat&#39;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;pixel_lon&#39;</span><span class="p">]]</span> <span class="o">*</span> 
                    <span class="n">x</span><span class="p">[</span><span class="s1">&#39;Schedule&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>
            <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;Personal_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;unique_days_idx&#39;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;pixel_lat&#39;</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;pixel_lon&#39;</span><span class="p">]]</span> <span class="o">*</span> 
                    <span class="n">x</span><span class="p">[</span><span class="s1">&#39;Schedule&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;ER&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

            <span class="c1"># extra step necessary to ensure correct assignment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temp_table</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temp_table</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="s1">&#39;Personal_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_table</span><span class="p">[</span><span class="s1">&#39;Personal_dose&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># TO DO: improve units options here</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ambient_dose&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">40</span><span class="o">*</span><span class="mi">3600</span><span class="o">/</span><span class="mi">100</span> <span class="c1"># SED</span>
        <span class="k">return</span> <span class="bp">self</span>        </div></div>


















<div class="viewcode-block" id="ExposureMap"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.ExposureMap">[docs]</a><span class="k">class</span> <span class="nc">ExposureMap</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; is a class for calculating maps based on user specifications</span>

<span class="sd">    Each instance of this class contains information required to calculate and illustrate a map</span>
<span class="sd">    of exposure information, be that simple averages or more advanced mathematical representations</span>
<span class="sd">    of exposure risk. The class is designed to have three core functions run in sequence, with</span>
<span class="sd">    room for flexibility should more advanced users desire it. First, the data is read and a pixel</span>
<span class="sd">    histogram is calculated. This allows much more data to be stored in memory and is the basis</span>
<span class="sd">    for performing this kind of data analysis on personal computers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    units : str</span>
<span class="sd">        The units of the quantity to be mapped. Must be &quot;SED&quot;, &quot;J m-2&quot; or &quot;UVIh&quot; for doses or &quot;UVI&quot;,</span>
<span class="sd">        &quot;W m-2&quot; or &quot;mW m-2&quot; for irradiances. Defaults to &quot;SED&quot;.</span>

<span class="sd">    exposure_schedule : array (length-24)</span>
<span class="sd">        A vector of values describing the relative exposure of each hour of the day. 0 indicates no</span>
<span class="sd">        exposure, 1 indicates full exposure, and a fractional value such as 0.5 would indicate </span>
<span class="sd">        exposure for a total of 30 minutes within the hour, or a 50% partial exposure for the full</span>
<span class="sd">        hour, or anything equivalent. Values greater than 1 are allowed. When not calculating doses,</span>
<span class="sd">        hours with any non-zero entry in this vector are included, with the corresponding irradiance</span>
<span class="sd">        value being multiplied by the value</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s2">&quot;SED&quot;</span><span class="p">,</span>
    <span class="n">exposure_schedule</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span>
    <span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">bin_width</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
    <span class="n">date_selection</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">map_options</span><span class="o">=</span><span class="n">default_map_options</span><span class="p">,</span>
    <span class="n">nc_filename_format</span><span class="o">=</span><span class="n">default_nc_filename_format</span><span class="p">,</span>
    <span class="n">data_directory</span><span class="o">=</span><span class="n">default_data_directory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span><span class="o">=</span><span class="n">exposure_schedule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">statistic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span> <span class="o">=</span> <span class="n">map_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span> <span class="o">=</span> <span class="n">nc_filename_format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_directory</span> <span class="o">=</span> <span class="n">data_directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date_selection</span> <span class="o">=</span> <span class="n">date_selection</span>
        <span class="k">if</span> <span class="n">bin_width</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span> <span class="o">=</span> <span class="n">default_bin_widths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">]</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span> <span class="o">=</span> <span class="n">bin_width</span>
    
<div class="viewcode-block" id="ExposureMap.collect_data"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.ExposureMap.collect_data">[docs]</a>    <span class="k">def</span> <span class="nf">collect_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nc_filename_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">date_selection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">exposure_schedule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bin_width</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;collect_data calculates histograms for each pixel of the underlying data</span>

<span class="sd">        In order to handle large amounts of data without exceeding memory limitations, files are</span>
<span class="sd">        loaded one at a time and the time dimension is removed, either by calculating daily doses</span>
<span class="sd">        or by simply taking the data as is. The resulting information is then stored not as a </span>
<span class="sd">        list of specific values but rather binned into a histogram for each pixel. This process</span>
<span class="sd">        is repeated for each file required by the user input, building up the pixel histograms</span>
<span class="sd">        with more information that does not require additional memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_directory : str, optional</span>
<span class="sd">            Directory containing multi-file dataset.</span>

<span class="sd">        nc_filename_format : str, optional</span>
<span class="sd">            Filename of multi-file dataset with year replaced by &#39;yyyy&#39;.</span>

<span class="sd">        date_selection : pandas.DateTimeIndex, optional</span>
<span class="sd">            The list of dates from which to pull data. Untested, but other datatypes probably </span>
<span class="sd">            acceptable. Currently relies on output from pandas.date_range function.</span>

<span class="sd">        units : str, optional</span>
<span class="sd">            Name of units of desired output. This also indicates whether daily doses must be </span>
<span class="sd">            calculated or not. Units of &quot;SED&quot;, &quot;J m-2&quot;, or &quot;UVIh&quot; will produce daily doses,</span>
<span class="sd">            units of &quot;UVI&quot;, &quot;W m-2&quot; or &quot;mW m-2&quot; will not. </span>

<span class="sd">        exposure_schedule : array, optional</span>
<span class="sd">            A length-24 array of values indicating the proportion of the corresponding hour</span>
<span class="sd">            spent fully exposed. A value of 1 indicates full exposure, 0 indicates no </span>
<span class="sd">            exposure, and 0.5 could indicate either half an hour of exposure or a full hour </span>
<span class="sd">            of 50% exposure. </span>

<span class="sd">        bin_width : float, optional</span>
<span class="sd">            The width of the histogram bins according to the chosen units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExposureMap</span>
<span class="sd">            The input ExposureMap object is appended with new fields, ``pix_hist`` contains</span>
<span class="sd">            the counts for the histogram, and ``bin_edges``, `bin_centers``, and ``num_bins``</span>
<span class="sd">            all serve as metadata for the pixel histograms. ``lat`` and ``lon`` are also </span>
<span class="sd">            added from the multi-file dataset to inform the pixel locations for map making</span>
<span class="sd">            further down the typical pipeline.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TO DO: There must be a better way to do this</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_directory</span> <span class="o">=</span> <span class="n">data_directory</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nc_filename_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span> <span class="o">=</span> <span class="n">nc_filename_format</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">date_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">date_selection</span> <span class="o">=</span> <span class="n">date_selection</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">exposure_schedule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span> <span class="o">=</span> <span class="n">exposure_schedule</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bin_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span> <span class="o">=</span> <span class="n">bin_width</span>

        <span class="c1"># first we read the data_directory to check the total number of unique years available</span>
        <span class="n">data_dir_contents</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_directory</span><span class="p">)</span>
        <span class="c1"># TO DO: improve jankiness of this format-matching search for filenames</span>
        <span class="n">char_year</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;yyyy&#39;</span><span class="p">)</span>
        <span class="n">dataset_years</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_dir_contents</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;yyyy&quot;</span><span class="p">,</span><span class="s2">&quot;[0-9]</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">),</span><span class="n">x</span><span class="p">)]</span>
        <span class="n">dataset_years</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">char_year</span><span class="p">:</span><span class="n">char_year</span><span class="o">+</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset_years</span> <span class="p">]</span>

        <span class="c1"># Now we can handle default options like &quot;all&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">date_selection</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">date_selection</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="p">:</span>
            <span class="n">date_selection</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">dataset_years</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;-01-01&quot;</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">dataset_years</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;-12-31&quot;</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">date_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date_selection</span> <span class="c1"># TO DO: much more interpretation options here</span>

        <span class="c1">#now we find unique years </span>
        <span class="n">list_of_years</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">date_selection</span><span class="o">.</span><span class="n">year</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_years</span><span class="p">))</span> <span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">list_of_years</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing year &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> <span class="c1">#should use logging, don&#39;t yet know how</span>
            <span class="n">dataset</span><span class="o">=</span><span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_directory</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">nc_filename_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;yyyy&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)))</span> 
            <span class="n">dataset</span><span class="o">.</span><span class="n">set_auto_mask</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#to get normal arrays (faster than default masked arrays)</span>

            <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">24</span> <span class="p">:</span>
                <span class="c1"># needed if just a single day</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="c1"># Next we pull a subset from the netCDF file</span>
                <span class="c1"># declare false array with same length of time dimension from netCDF</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span> 
                <span class="c1"># reshape false array to have first dimension 24 (hours in day)</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">time_subset</span><span class="p">)</span> 
                <span class="c1"># set the appropriate days as true</span>
                <span class="n">time_subset</span><span class="p">[:,</span><span class="n">date_selection</span><span class="p">[</span><span class="n">date_selection</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="n">year</span><span class="p">]</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 
                <span class="c1"># flatten time_subset array back to one dimension</span>
                <span class="n">time_subset</span> <span class="o">=</span> <span class="n">time_subset</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

            <span class="c1"># load subset of data</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Slicing netcdf data with time subset&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;UV_AS&#39;</span><span class="p">][</span><span class="n">time_subset</span><span class="p">,:,:]</span><span class="o">*</span><span class="mi">40</span> <span class="c1">#work in UVI by default because it&#39;s easy to read</span>
            <span class="c1"># TO DO: check units of dataset files, CF conventions for UVI or W/m2</span>

            <span class="c1"># now to calculate doses if requested</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SED&quot;</span><span class="p">,</span><span class="s2">&quot;J m-2&quot;</span><span class="p">,</span><span class="s2">&quot;UVIh&quot;</span><span class="p">]</span> <span class="p">:</span>
                <span class="c1"># if calculating doses</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Calculating doses&#39;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span><span class="p">,[</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">24</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="p">:</span>
                <span class="c1"># assume elsewise calculating intensity (i.e. UV-index) then limit data selection according</span>
                <span class="c1"># to schedule (remembering that default schedule is just ones)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Slicing data with exposure schedule&#39;</span><span class="p">)</span>
                <span class="c1"># reshape so first dimension is 24 hours</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># select only those hours with nonzero entry in exposure schedule</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,:,:,:]</span>
                <span class="c1"># select nonzero values from exposure schedule</span>
                <span class="n">exposure_schedule_nonzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure_schedule</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># if any nonzero entries aren&#39;t 1, multiply data accordingly</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">exposure_schedule_nonzero</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="p">:</span>
                    <span class="n">data</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">exposure_schedule_nonzero</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">exposure_schedule_nonzero</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># recombine first two dimensions (hour and day) back into time ready for histogram</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">assert_data_shape_24</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

            <span class="c1"># now multiply data by conversion factor according to desired untis</span>
            <span class="c1"># TO DO: Should expand upon this in reference files</span>
            <span class="n">data</span> <span class="o">*=</span> <span class="p">{</span><span class="s2">&quot;SED&quot;</span><span class="p">:</span><span class="mf">0.9</span><span class="p">,</span> <span class="s2">&quot;J m-2&quot;</span><span class="p">:</span><span class="mi">90</span><span class="p">,</span> <span class="s2">&quot;UVIh&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;UVI&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;W m-2&quot;</span><span class="p">:</span><span class="mf">0.025</span><span class="p">,</span> <span class="s2">&quot;mW m-2&quot;</span><span class="p">:</span><span class="mi">25</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">]</span>

            <span class="c1"># if this is the first iteration, declare a hist</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="c1"># seems like useful metadata to know bin n and edges</span>
                <span class="c1"># TO DO: reconsider where this belongs in the code (__init__?)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>

                <span class="c1"># TO DO: think about possible cases where dimensions could differ</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pix_hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

                <span class="c1"># TO DO: this should also be done by some initial dataset analysis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lon</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:]</span>

            <span class="c1"># TO DO: add check here in case max exceeds current bin edges</span>
            <span class="c1"># now put data into hist using apply_along_axis to perform histogram for each pixel</span>
            <span class="k">def</span> <span class="nf">hist_raw</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span>
                <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">hist</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Calculating and adding to pix hist&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pix_hist</span><span class="p">[:,:,:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">hist_raw</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ExposureMap.calculate_map"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.ExposureMap.calculate_map">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pix_hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">statistic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bin_centers</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;calculate_map calculates statistical descriptor values for pixel histograms to produce a map</span>

<span class="sd">        This function interprets the statistic string, which can either be a simple command</span>
<span class="sd">        such as &quot;mean&quot; or a more advanced formula of keywords. The corresponding function is </span>
<span class="sd">        applied to each pixel of the pix_hist object within the ExposureMap class, essentially</span>
<span class="sd">        removing the first dimension and resulting in straightforward map to be plotted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pix_hist : array, optional</span>
<span class="sd">            A 3D array with the first dimension containing vectors of counts for histograms</span>
<span class="sd">            and the next two dimensions serving as pixel coordinates. See </span>
<span class="sd">            ExposureMap.collect_data for more information.</span>

<span class="sd">        stastistic : str, optional</span>
<span class="sd">            If this string is equivalent to one of the following (case insensitive), then the</span>
<span class="sd">            corresponding function will be applied; &quot;mean&quot;, &quot;median&quot; or &quot;med&quot;, &quot;sd&quot; or &quot;std&quot; </span>
<span class="sd">            or &quot;stdev&quot;, &quot;max&quot; or &quot;maximum&quot;, &quot;min&quot; or &quot;minimum&quot;.</span>

<span class="sd">            *Planned:* the string can otherwise be a formula using any of the keywords above,</span>
<span class="sd">            as well at &quot;prct&quot; or &quot;percentile&quot; preceeded by a number between 0 and 100, and </span>
<span class="sd">            basic mathematical operators (+, -, *, /, **) and numeric factors.</span>
<span class="sd">            </span>
<span class="sd">        bin_centers : array, optional</span>
<span class="sd">            The central numeric values corresponding to the bins in pix_hist</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExposureMap</span>
<span class="sd">            The ExposureMap class object is appended with a map field containing a 2D array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pix_hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pix_hist</span> <span class="o">=</span> <span class="n">pix_hist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">statistic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">statistic</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bin_centers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span> <span class="o">=</span> <span class="n">bin_centers</span>

        <span class="c1"># Begin by defining the easy options that only require two inputs</span>
        <span class="n">basic_descriptor_functions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">hist_mean</span><span class="p">,</span>
            <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">hist_percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span>
            <span class="s2">&quot;med&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">hist_percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span>
            <span class="s2">&quot;sd&quot;</span><span class="p">:</span> <span class="n">hist_stdev</span><span class="p">,</span>
            <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">hist_stdev</span><span class="p">,</span>
            <span class="s2">&quot;stdev&quot;</span><span class="p">:</span> <span class="n">hist_stdev</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">hist_max</span><span class="p">,</span>
            <span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">hist_max</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">hist_min</span><span class="p">,</span>
            <span class="s2">&quot;minimum&quot;</span><span class="p">:</span><span class="n">hist_min</span>
        <span class="p">}</span>
        <span class="c1"># we can check if the chosen statistic is basic or advanced</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basic_descriptor_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">:</span>
            <span class="c1"># in this case, we can simply select the basic function from the dict...</span>
            <span class="n">descriptor_function</span> <span class="o">=</span> <span class="n">basic_descriptor_functions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">statistic</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="c1"># ...and execute it across the map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">descriptor_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pix_hist</span><span class="p">)</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="c1"># TO DO: interpret self.statistic to build advanced functions (y i k e s)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: ExposureMap.statistic not recognised.&quot;</span><span class="p">)</span>
        

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ExposureMap.plot_map"><a class="viewcode-back" href="../../python_tamer.html#python_tamer.library.ExposureMap.plot_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">map_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;plot_map renders and saves a map of the calculated quantity</span>

<span class="sd">        This function caps off the typical workflow for the ExposureMap class by rendering the contents</span>
<span class="sd">        of the map property. Many aesthetic factors are accounted for, contained within the</span>
<span class="sd">        ExposureMap.map_options dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        map_options : dict, optional</span>
<span class="sd">            A collection of many typical options such as image and font sizes, colormaps, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">map_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span> <span class="o">=</span> <span class="n">map_options</span>

        <span class="c1"># TO DO: Add custom sizing and resolution specifications</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.54</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.54</span><span class="p">))</span>

        <span class="c1"># TO DO: Accept custom projections</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Mercator</span><span class="p">()</span>

        <span class="c1"># TO DO: Add support for multiple plots per figure (too complex? consider use cases)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">projection</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>

        <span class="c1"># TO DO: Increase flexibility of borders consideration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;brdr_nation&#39;</span><span class="p">]</span> <span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">cfeat</span><span class="o">.</span><span class="n">BORDERS</span><span class="p">)</span>

        <span class="c1"># TO DO: Consider first-last versus min-max - how can we avoid accidentally flipping images</span>
        <span class="n">extents</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">extents</span><span class="p">)</span>

        <span class="c1"># Confusingly, this code correctly translate the lat/lon limits into the projected coordinates</span>
        <span class="n">extents_proj</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">ccrs</span><span class="o">.</span><span class="n">Geodetic</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extents</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extents</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="n">extents_proj</span> <span class="o">=</span> <span class="n">extents_proj</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># TO DO: Custom colormaps, interpolation, cropping</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extents_proj</span><span class="p">,</span><span class="n">transform</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mapoptions</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">],</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bicubic&#39;</span><span class="p">)</span>

        <span class="c1"># TO DO: Add support for horizontal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;cbar&#39;</span><span class="p">]</span> <span class="p">:</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">fraction</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

        <span class="c1"># TO DO: Add plot title, small textbox description, copyright from dataset, ticks and gridlines</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;save&#39;</span><span class="p">]</span> <span class="p">:</span>
            <span class="c1"># Generate timestamp filename if relying on default</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;img_filename&#39;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;default&quot;</span> <span class="p">:</span>
                <span class="n">img_filename</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">_%H%M%S_</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;img_dir&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">img_filename</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;img_filetype&#39;</span><span class="p">],</span>
                <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_options</span><span class="p">[</span><span class="s1">&#39;dpi&#39;</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>


</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">python-TAMER</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">python-TAMER</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">python-tamer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Todd C. Harris.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>